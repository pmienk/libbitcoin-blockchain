/**
 * Copyright 2011-2015
 *
 * Modified from https://github.com/BoostGSoC13/boost.trie
 *
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef LIBBITCOIN_BLOCKCHAIN_PRIMARY_PREFIXED_SECONDARY_ORDERED_PATRICIA_TRIE_IPP
#define LIBBITCOIN_BLOCKCHAIN_PRIMARY_PREFIXED_SECONDARY_ORDERED_PATRICIA_TRIE_IPP

#include <new>

namespace libbitcoin {
namespace blockchain {

// modified_patricia_trie implementation
template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
modified_patricia_trie<K, V, KC, VC, SNA, VNA>::modified_patricia_trie(
    structure_node_allocator structure_allocator,
    value_node_allocator value_allocator)
    : structure_allocator_(structure_allocator),
      value_allocator_(value_allocator), root_(create_structure_node()),
      end_(secondary_key_type(), root_)
{
//    root_->next = root_;
//    root_->previous = root_;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
modified_patricia_trie<K, V, KC, VC, SNA, VNA>::~modified_patricia_trie()
{
    destroy();
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::destroy()
{
    auto current = get_leftmost_leaf(root_);

    while ((current != root_))
    {
        auto last = current;
        auto parent = current->parent;

        if (current != parent->get_last_child())
            current = get_leftmost_leaf(parent->get_last_child());
        else
            current = parent;

        parent->remove_child(last);
        destroy_structure_node(last);
    }

    destroy_structure_node(root_);

    root_ = nullptr;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::create_structure_node()
{
    auto node = structure_allocator_.allocate(1);
    if (node == nullptr)
        throw std::bad_alloc();

    new (node)structure_node_type();
    return node;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::create_structure_node(
        const binary_type& key)
{
    auto node = create_structure_node();
    node->label = key;
    return node;
}

//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::create_structure_node(
//        const binary_type& key, const value_node_type* value_node)
//{
//    auto node = create_structure_node(key);
//    append_value(node, value_node);
//    return node;
//}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::create_structure_node(
        const binary_type& primary, const secondary_key_type& secondary,
        const value_type& value)
{
    auto node = create_structure_node(primary);
    auto value_node = create_value_node(value);
    append_value(node, secondary, value_node);
    return node;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
bool modified_patricia_trie<K, V, KC, VC, SNA, VNA>::destroy_structure_node(
    structure_node_type* node)
{
    auto result = false;
    if (node != nullptr)
    {
        erase_values(node);
        structure_allocator_.destroy(node);
        structure_allocator_.deallocate(node, 1);
        result = true;
    }

    return result;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::erase_values(
    structure_node_type* node)
{
    if (node != nullptr)
    {
        for (auto it = node->store.begin(); it != node->store.end(); ++it)
        {
            auto* value = (*it).head;

            while (value != nullptr)
            {
                auto* next = value->next;
                destroy_value_node(value);
                value = next;
            }

            (*it).head = nullptr;
            (*it).tail = nullptr;
        }
    }
}

////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::erase_subtree(
////    structure_node_type* node)
////{
////    if (node != nullptr)
////    {
////        // identify previous/next pointers which need reset to separate
////        // the subtree from the rest of the tree
////        auto* first_in_subtree = node;
////        structure_node_type* previous_outside_subtree = nullptr;
////
////        if (node->value_leftmost != nullptr)
////        {
////            first_in_subtree = node->value_leftmost->anchor;
////            previous_outside_subtree = first_in_subtree->previous;
////        }
////
////        auto* last_in_subtree = node;
////        structure_node_type* next_outside_subtree = nullptr;
////
////        if (node->value_rightmost != nullptr)
////        {
////            last_in_subtree = node->value_rightmost->anchor;
////            next_outside_subtree = last_in_subtree->next;
////        }
////
////        // sever the subtree from the remaining tree by resetting
////        // previous, next, parent and child pointers
////        auto* parent_from_tree = node->parent;
////
////        if (parent_from_tree != nullptr)
////        {
////            parent_from_tree->set_child(node->label[0], nullptr);
////            node->parent = nullptr;
////        }
////
////        first_in_subtree->previous = node;
////        last_in_subtree->next = node;
////
////        if (previous_outside_subtree != nullptr)
////            previous_outside_subtree->next = next_outside_subtree;
////
////        if (next_outside_subtree != nullptr)
////            next_outside_subtree->previous = previous_outside_subtree;
////
////        // should be done, can't do it now without propegating nullptrs
////        // update_left_and_right_branch(parent_from_tree);
////
////        // descend first children to leaf
////        auto* current = get_leftmost_leaf(node);
////
////        // erase node, remembering parent and which child was matching
////        // if not first child, current is parent
////        // otherwise descend first children of last child until leaf
////        while (current != nullptr)
////        {
////            auto* next = current->parent;
////            if (next != nullptr)
////            {
////                if (next->get_last_child() != current)
////                    next = get_leftmost_leaf(next->get_last_child());
////
////                current->parent->set_child(current->label[0], nullptr);
////            }
////
////            // destroy the leaf, regardless of contained values
////            destroy_structure_node(current);
////            current = next;
////        }
////    }
////}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::compress_branch(
//        structure_node_type* node)
//{
//    if (node != nullptr)
//    {
//        auto update = true;
//
//        // while not the trie root (designated by null parent), having no value
//        // and having no children, delete leaf and replace reference with its parent
//        while ((node->parent != nullptr) && !node->has_value())
//        {
//            auto parent = node->parent;
//            if (node->has_children())
//            {
//                // Can we collapse this node out of the trie before termination?
//                if (node->get_first_child() == node->get_last_child())
//                {
//                    auto replacement = node->get_last_child();
//                    replacement->label.prepend(node->label);
//                    attach_child(parent, replacement);
//                    destroy_structure_node(node);
//                    node = replacement;
//                    update = false; // was triggered by attach_child
//                }
//
//                break;
//            }
//
//            // remove child reference within parent, delete leaf
//            parent->set_child(node->label[0], nullptr);
//            unlink_node(node);
//            destroy_structure_node(node);
//            node = parent;
//        }
//
//        if (update)
//            update_left_and_right_branch(node);
//    }
//
//    return node;
//}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::value_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::create_value_node(
        const value_type& value)
{
    auto* node = value_allocator_.allocate(1);
    if (node == nullptr)
        throw std::bad_alloc();

    new (node)value_node_type(value);
    return node;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
bool modified_patricia_trie<K, V, KC, VC, SNA, VNA>::destroy_value_node(
    value_node_type* node)
{
    auto result = false;
    if (node != nullptr)
    {
        value_allocator_.destroy(node);
        value_allocator_.deallocate(node, 1);
        result = true;
    }

    return result;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::value_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::append_value(
        structure_node_type* node, const secondary_key_type& key,
        value_node_type* value_node)
{
    auto update = false;
    auto bounds_query = node->store.retrieve(key);

    if (!bounds_query.second)
        bounds_query = node->store.add(key, { nullptr, nullptr, nullptr, nullptr }, true);

    value_node->anchor = node;
    value_node->next = (*bounds_query.first).head;

    auto* previous = (*bounds_query.first).tail;

    while ((previous != nullptr) &&
        !value_comparer_(value_node->value, previous->value))
        previous = previous->previous;

    if (previous != nullptr)
    {
        auto* next = previous->next;
        previous->next = value_node;
        value_node->previous = previous;
        value_node->next = next;

        if (next != nullptr)
            next->previous = value_node;
    }

    if (previous == (*bounds_query.first).tail)
    {
        update = true;
        (*bounds_query.first).tail = value_node;
    }

    if (previous == nullptr)
    {
        update = true;
        value_node->next = (*bounds_query.first).head;
        (*bounds_query.first).head = value_node;
    }

    // fixup left/right pointers
    if (update)
        update_left_and_right_branch(node, key);

    return value_node;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::value_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::append_value(
        structure_node_type* node, const secondary_key_type& key,
        const value_type& value)
{
    auto* value_node = create_value_node(value);
    return append_value(node, key, value_node);
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::get_leftmost_leaf(
        structure_node_type* origin) const
{
    auto* current = origin;
    while (current->has_children())
        current = current->get_first_child();

    return current;
}

//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::get_rightmost_leaf(
//        structure_node_type* origin) const
//{
//    auto* current = origin;
//    while (current->has_children())
//        current = current->get_last_child();
//
//    return current;
//}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::get_leftmost_node(
//        structure_node_type* origin) const
//{
//    auto* current = origin;
//    while (current->has_children() && !(current->has_value()))
//        current = current->get_first_child();
//
//    return current;
//}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::get_rightmost_node(
//        structure_node_type* origin) const
//{
//    return get_rightmost_leaf(origin);
//}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::update_left_and_right(
    structure_node_type* node, const secondary_key_type& key)
{
    if (!node->has_children(key))
    {
        auto result = node->store.retrieve(key);

        if (result.second)
        {
            (*result.first).leftmost = (*result.first).head;
            (*result.first).rightmost = (*result.first).tail;
        }
    }
    else
    {
        auto key_bounds = node->store.retrieve(key);

        if (!key_bounds.second)
            key_bounds = node->store.add(key,
                typename structure_node_type::value_boundaries());

        if (key_bounds.second)
        {
            if ((*key_bounds.first).head != nullptr)
                (*key_bounds.first).leftmost = (*key_bounds.first).head;
            else
            {
                auto first_child_bounds = node->get_first_child(key)->store.retrieve(key);
                (*key_bounds.first).leftmost = (*first_child_bounds.first).leftmost;
            }

            auto last_child_bounds = node->get_last_child(key)->store.retrieve(key);
            (*key_bounds.first).rightmost = (*last_child_bounds.first).rightmost;
        }
    }
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::update_left_and_right_branch(
    structure_node_type* node, const secondary_key_type& key)
{
    if (node != nullptr)
    {
        // fixup left/right pointers
        auto temp = node;
        while (temp != nullptr)
        {
            update_left_and_right(temp, key);
            temp = temp->parent;
        }
    }
}

//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::next_node_with_value(
//        structure_node_type* node)
//{
//    // if at root (designated by null parent), terminate
//    if (node->parent == nullptr)
//        return node;
//
//    auto next = node;
//    if (next->has_children())
//    {
//        // if this node has a child, then at least one value will be located
//        // within the subtree, walk the subtree favoring first child until
//        // a value is reached
//        do
//        {
//            next = next->get_first_child();
//        } while (!next->has_value());
//    }
//    else
//    {
//        // if a leaf, back up until a sibling is reached
//        while (next->parent != nullptr)
//        {
//            auto parent = next->parent;
//
//            // if sibling found, decend first children until value
//            if (parent->get_last_child() != next)
//            {
//                next = get_leftmost_node(parent->get_last_child());
//                break;
//            }
//
//            next = parent;
//        }
//    }
//
//    return next;
//}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::link_node(
//    structure_node_type* node)
//{
//    unlink_node(node);
//    auto next = next_node_with_value(node);
//    auto previous = next->previous;
//    node->next = next;
//    node->previous = previous;
//    next->previous = node;
//    previous->next = node;
//}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::unlink_node(
//    structure_node_type* node)
//{
//    // only unlink linked nodes (note that the root node is linked)
//    if ((node->next != nullptr) && (node->previous != nullptr))
//    {
//        auto next = node->next;
//        auto previous = node->previous;
//        previous->next = next;
//        next->previous = previous;
//        node->previous = nullptr;
//        node->next = nullptr;
//    }
//}
//
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::begin()
////{
////    auto value = root_->value_leftmost;
////    return (value != nullptr) ? (iterator)value : (iterator)root_;
////}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::iterator
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::end()
{
    return end_;
}

////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::begin() const
////{
////    auto value = root_->value_leftmost;
////    return (value != nullptr) ? (const_iterator)value : (const_iterator)root_;
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::end() const
////{
////    return (const_iterator)root_;
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::cbegin() const
////{
////    auto value = root_->value_leftmost;
////    return (value != nullptr) ? (const_iterator)value : (const_iterator)root_;
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::cend() const
////{
////    return (const_iterator) root_;
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::rbegin()
////{
////    return static_cast<reverse_iterator>(end());
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::rend()
////{
////    return static_cast<reverse_iterator>(begin());
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::rbegin() const
////{
////    return static_cast<const_reverse_iterator>(end());
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::rend() const
////{
////    return static_cast<const_reverse_iterator>(begin());
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::crbegin() const
////{
////    return rbegin();
////}
////
////template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
////typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::const_reverse_iterator
////    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::crend() const
////{
////    return rend();
////}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::attach_child(
    const secondary_key_type& key, structure_node_type* parent,
    structure_node_type* child)
{
    // note: method trusts that the parent's child is safely overwriteable
    child->parent = parent;
    parent->set_child(child->label[0], child);
    if (child->has_value(key))
    {
//        link_node(child);
        update_left_and_right_branch(child, key);
    }
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
void modified_patricia_trie<K, V, KC, VC, SNA, VNA>::attach_child(
    structure_node_type* parent, structure_node_type* child)
{
    // note: method trusts that the parent's child is safely overwriteable
    child->parent = parent;
    parent->set_child(child->label[0], child);

    for (auto it = child->store.begin(); it != child->store.end(); ++it)
        update_left_and_right_branch(child, it.get_key());
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::insert_at(
        structure_node_type* current, const binary_type& key)
{
    auto host = create_structure_node(key);
    attach_child(current, host);
    return host;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::structure_node_type*
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::insert_at(
        structure_node_type* current, const binary_type& primary,
        const secondary_key_type& secondary, const value_type& value)
{
    auto host = create_structure_node(primary, secondary, value);
    attach_child(secondary, current, host);
    return host;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_iterator_bool
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::insert(
        structure_node_type*& current, const binary_type& primary,
        const secondary_key_type& secondary, const value_type& value)
{
    binary_type::size_type key_offset = 0;
    for (; key_offset < primary.size();)
    {
        auto initial_match = current->get_child(primary[key_offset]);
        if (initial_match == nullptr)
        {
            auto subkey = primary.get_substring(key_offset,
                primary.size() - key_offset);
            auto node = insert_at(current, subkey, secondary, value);
            auto value_bounds = node->store.retrieve(secondary);

            return std::make_pair(
                iterator(secondary, (*(value_bounds.first)).head),
                true);
        }

        // scan for substring mismatch with label, note scan begins at
        // second character as first character was redundantly encoded
        // and checked during child choice for the loop's examination
        bool matches_label = true;
        bool initial_match_label_exceeds_key = false;
        binary_type::size_type label_offset = 1;

        for (; (label_offset < initial_match->label.size()); label_offset++)
        {
            if ((key_offset + label_offset) >= primary.size())
            {
                initial_match_label_exceeds_key = true;
                break;
            }

            if (initial_match->label[label_offset] !=
                primary[key_offset + label_offset])
            {
                matches_label = false;
                break;
            }
        }

        if (!matches_label || initial_match_label_exceeds_key
            || (label_offset != initial_match->label.size()))
        {
            // if there is a disagreement, introduce intermediary node
            // and insert the new branch
            auto intermediary_key = initial_match->label.get_substring(0,
                label_offset);

            auto trailing_initial_key = initial_match->label.get_substring(
                label_offset);

            // unlink/remove the initial_match from the tree
//            unlink_node(initial_match);
            initial_match->parent = nullptr;

            // add intermediary to tree
            auto intermediary = insert_at(current, intermediary_key);

            // add back initial_match with reduced label
            initial_match->label = trailing_initial_key;
            attach_child(intermediary, initial_match);

            if (primary.size() > (key_offset + label_offset))
            {
                // if the key has remaining length, insert a sibling
                auto remaining_key = primary.get_substring(
                    key_offset + label_offset);

                return std::make_pair(iterator(secondary, insert_at(
                    intermediary, remaining_key, secondary, value)), true);
            }
            else
            {
                // otherwise intermediary label must be key, so add value to
                // the intermediary which was uniquely added and link_node
                auto* inserted = append_value(intermediary, secondary, value);
//                link_node(intermediary);

                current = intermediary;
                return std::make_pair(iterator(secondary, inserted), true);
            }
        }
        else
        {
            // otherwise, loop decending the tree
            current = initial_match;
            key_offset += label_offset;
        }
    }

    return std::make_pair(iterator(secondary, current), false);
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_iterator_bool
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::insert_equal(
        const binary_type& primary, const secondary_key_type& secondary,
        const value_type& value)
{
    auto current = root_;
    auto result = insert(current, primary, secondary, value);

    // if we haven't created a node yet, but exhausted our key
    // we must have matched an existing node, we can append here
    // though we aren't guaranteed to be unique
    if (!result.second && (current != root_))
    {
//        auto linked = current->has_value();
        auto inserted = append_value(current, secondary, value);
//        if (!linked)
//            link_node(current);

        return std::make_pair(iterator(secondary, inserted), true);
    }

    return result;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_iterator_bool
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::insert_unique(
        const binary_type& primary, const secondary_key_type& secondary,
        const value_type& value)
{
    auto current = root_;
    auto result = insert(current, primary, secondary, value);

    // if we haven't created a node yet, but exhausted our key
    // we must have matched an existing node, if it has no value
    // we can introduce one here
    if (!result.second && !current->has_value(secondary) && (current != root_))
    {
        auto inserted = append_value(current, secondary, value);
        return std::make_pair(iterator(secondary, inserted), true);
    }

    return result;
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_node_size
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::find_closest_subkey_matching_node(
        structure_node_type* start, const binary_type& key)
{
    auto match = true;
    auto current = start;
    binary_type::size_type key_offset = 0;
    for (; match && (current != nullptr) && (key_offset < key.size());)
    {
        auto initial_match = current->get_child(key[key_offset]);
        if (initial_match != nullptr)
        {
            for (binary_type::size_type label_offset = 0;
                (label_offset < initial_match->label.size()) &&
                    (key_offset + label_offset < key.size()); label_offset++)
            {
                if (key[key_offset + label_offset]
                    != initial_match->label[label_offset])
                {
                    match = false;
                    break;
                }
            }

            key_offset += initial_match->label.size();
        }

        current = initial_match;
    }

    if (!match)
    {
        current = nullptr;
    }

    return std::make_pair(current, key_offset);
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_query_result_bool
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::find_equal(
        const binary_type& primary)
{
    auto find_pair = find_closest_subkey_matching_node(root_, primary);
    bool failure =  (find_pair.second == 0) || (find_pair.first == nullptr) ||
        (find_pair.second != primary.size());

    return std::make_pair(query_result(find_pair.first), !failure);
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::iterator_range
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::find_equal(
        const binary_type& primary, const secondary_key_type& secondary)
{
    auto primary_key_query_result = find_equal(primary);

    if (primary_key_query_result.second)
        return primary_key_query_result.first.get_exact(secondary);

    return std::make_pair(end(), end());
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::pair_query_result_bool
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::find_prefixed(
        const binary_type& primary)
{
    auto find_pair = find_closest_subkey_matching_node(root_, primary);
    bool failure =  (find_pair.second == 0) || (find_pair.first == nullptr);

    return std::make_pair(query_result(find_pair.first), !failure);
}

template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::iterator_range
    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::find_prefixed(
        const binary_type& primary, const secondary_key_type& secondary)
{
    auto primary_key_query_result = find_prefixed(primary);

    if (primary_key_query_result.second)
        return primary_key_query_result.first.get_prefixed(secondary);

    return std::make_pair(end(), end());
}

//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//bool modified_patricia_trie<K, V, KC, VC, SNA, VNA>::remove_equal(
//    const binary_type& key, const secondary_key_type& secondary)
//{
//    auto find_pair = find_closest_subkey_matching_node(root_, key);
//    auto nonremovable = ((find_pair.first == nullptr) ||
//        (find_pair.second != key.size()) || (find_pair.second == 0));
//
//    if (!nonremovable)
//    {
//        auto node = find_pair.first;
//        erase_values(node);
//        compress_branch(node);
//    }
//
//    return !nonremovable;
//}
//
//template <typename K, typename V, typename KC, typename VC, typename SNA, typename VNA>
//typename modified_patricia_trie<K, V, KC, VC, SNA, VNA>::iterator
//    modified_patricia_trie<K, V, KC, VC, SNA, VNA>::remove_value(iterator it)
//{
//    auto value_node = it.value_node_;
//    if (value_node == nullptr)
//        return it;
//
//    auto anchor = value_node->anchor;
//    if (anchor->value_head == anchor->value_tail)
//    {
//        auto next = anchor->next;
//
//        // otherwise, remove all values and attempt to remove the node
//        erase_values(anchor);
//        compress_branch(anchor);
//
//        return (iterator)(next);
//    }
//
//    // if the value can be removed without removing emptying the node
//    auto next = value_node->next;
//    auto previous = value_node->previous;
//
//    if (next != nullptr)
//        next->previous = previous;
//
//    if (previous != nullptr)
//        previous->next = next;
//
//    auto update = false;
//    value_node->next = nullptr;
//    value_node->previous = nullptr;
//
//    if (anchor->value_head == value_node)
//    {
//        anchor->value_head = next;
//        update = true;
//    }
//
//    if (anchor->value_tail == value_node)
//    {
//        anchor->value_tail = previous;
//        update = true;
//    }
//
//    destroy_value_node(value_node);
//
//    if (update)
//        update_left_and_right_branch(anchor);
//
//    return (next == nullptr) ? (iterator)(anchor->next) : (iterator)next;
//}

} // namespace blockchain
} // namespace libbitcoin

#endif
