/**
 * Copyright 2011-2015
 *
 * Modified from https://github.com/BoostGSoC13/boost.trie
 *
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef LIBBITCOIN_BLOCKCHAIN_PRIMARY_PREFIXED_SECONDARY_ORDERED_PATRICIA_TRIE_HPP
#define LIBBITCOIN_BLOCKCHAIN_PRIMARY_PREFIXED_SECONDARY_ORDERED_PATRICIA_TRIE_HPP

#include <cstdint>
#include <memory>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/utility.hpp>
#include <bitcoin/bitcoin.hpp>
#include <bitcoin/blockchain/trie/prefix_query_result.hpp>
#include <bitcoin/blockchain/trie/trie_reverse_iterator.hpp>
#include <bitcoin/blockchain/trie/trie_structure_node.hpp>
#include <bitcoin/blockchain/trie/trie_value_node.hpp>

namespace libbitcoin {
namespace blockchain {

template <std::size_t Size,
    typename Key,
    typename Value,
    typename KeyComparer = std::greater<Key>,
    typename ValueComparer = std::greater<Value>,
    typename StructureNodeAllocator = std::allocator<
        trie_structure_node<Key, Value, KeyComparer>>,
    typename ValueNodeAllocator = std::allocator<
        trie_value_node<Value, trie_structure_node<Key, Value, KeyComparer>>>>
class modified_patricia_trie
    : protected boost::noncopyable
{
public:

    typedef Key secondary_key_type;
    typedef Value value_type;
    typedef KeyComparer key_type_comparer;
    typedef ValueComparer value_type_comparer;
    typedef StructureNodeAllocator structure_node_allocator;
    typedef ValueNodeAllocator value_node_allocator;

    typedef modified_patricia_trie<Size, Key, Value,
        KeyComparer, ValueComparer, StructureNodeAllocator,
        ValueNodeAllocator> trie_type;

    typedef trie_structure_node<Key, Value, KeyComparer> structure_node_type;
    typedef trie_value_node<value_type, structure_node_type> value_node_type;

    typedef prefix_query_result<secondary_key_type, value_type,
        key_type_comparer> query_result;

    typedef typename query_result::iterator iterator;
    typedef typename iterator::const_iterator const_iterator;
    typedef trie_reverse_iterator<iterator> reverse_iterator;
    typedef trie_reverse_iterator<const_iterator> const_reverse_iterator;

    typedef std::pair<iterator, iterator> iterator_range;
    typedef std::pair<iterator, bool> pair_iterator_bool;

    typedef std::pair<query_result, bool> pair_query_result_bool;

    typedef std::pair<structure_node_type*, binary_type::size_type>
        pair_node_size;

public:

    // constructor/destructors
    modified_patricia_trie(
        structure_node_allocator trie_allocator,
        value_node_allocator value_allocator);

    ~modified_patricia_trie();

    // insertion
    pair_iterator_bool insert_equal(const binary_type& primary,
        const secondary_key_type& secondary, const value_type& value);

    pair_iterator_bool insert_unique(const binary_type& primary,
        const secondary_key_type& secondary, const value_type& value);

    // lookup
    // results will share a primary key
    iterator_range find_equal(const binary_type& primary,
        const secondary_key_type& secondary) const;

    pair_query_result_bool find_equal(const binary_type& primary) const;

    // results will span primary keys with matching prefix
    iterator_range find_prefixed(const binary_type& primary,
        const secondary_key_type& secondary) const;

    pair_query_result_bool find_prefixed(const binary_type& primary) const;

    iterator_range find_secondary_key_bounds(const secondary_key_type& key) const;

    // deletion
    bool remove_equal(const binary_type& primary,
        const secondary_key_type& secondary);

    bool remove_equal(const secondary_key_type& secondary);

    iterator remove_value(iterator it);

protected:

    void destroy();

    // structure node management
    structure_node_type* create_structure_node();

    structure_node_type* create_structure_node(const binary_type& key);

    structure_node_type* create_structure_node(const binary_type& primary,
        const secondary_key_type& secondary, const value_type& value);

    bool destroy_structure_node(structure_node_type* node);

    // value node management
    value_node_type* create_value_node(const value_type& value);

    bool destroy_value_node(value_node_type* node);

    // seek methods
    structure_node_type* get_leftmost_leaf(structure_node_type* origin) const;

    // next/previous/leftmost/rightmost pointer updates
    void update_left_and_right(structure_node_type* node,
        const secondary_key_type& key);

    void update_left_and_right_branch(structure_node_type* node,
        const secondary_key_type& key);

    // cleanup/teardown
    void erase_values(structure_node_type* node);

    value_node_type* disconnect_values(structure_node_type* node,
        const secondary_key_type& key);

    void erase_disconnected_list(value_node_type* head);

    structure_node_type* compress_branch(structure_node_type* node,
        const secondary_key_type& key);

    // tree append/insert
    pair_iterator_bool insert(structure_node_type*& current,
        const binary_type& primary, const secondary_key_type& secondary,
        const value_type& value);

    value_node_type* append_value(structure_node_type* node,
        const secondary_key_type& key, value_node_type* value_node);

    value_node_type* append_value(structure_node_type* node,
        const secondary_key_type& key, const value_type& value);

    structure_node_type* insert_at(structure_node_type* current,
        const binary_type& primary, const secondary_key_type& secondary,
        const value_type& value);

    structure_node_type* insert_at(structure_node_type* current,
        const binary_type& key);

    void attach_child(const secondary_key_type&key,
        structure_node_type* parent, structure_node_type* child);

    void attach_child(structure_node_type* parent, structure_node_type* child);

    pair_node_size find_closest_subkey_matching_node(
        structure_node_type* start, const binary_type& key) const;

private:

    structure_node_allocator structure_allocator_;
    value_node_allocator value_allocator_;
    value_type_comparer value_comparer_;
    structure_node_type* root_;
    iterator end_;
};

} // namespace blockchain
} // namespace libbitcoin

#include <bitcoin/blockchain/impl/trie/modified_patricia_trie.ipp>

#endif
